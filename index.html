<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Connect Four ‚Äì Enhanced Edition</title>
  <style>
    :root {
      --bg: #0a0e27;
      --card: #1a1f3a;
      --muted: #94a3b8;
      --text: #f1f5f9;
      --accent: #6366f1;
      --line: #2d3654;
      --hole: #0d1225;
      --p1: #ef4444;
      --p2: #fbbf24;
      --win: #22c55e;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif;
      color: var(--text);
      background: var(--bg);
      overflow-x: hidden;
    }

    #bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    #preloader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 16px;
      background: var(--bg);
      z-index: 100;
      transition: opacity 0.3s;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--line);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .loading-text {
      color: var(--text);
      font-weight: 600;
      font-size: 1.1em;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .hidden {
      display: none !important;
    }

    #app {
      position: relative;
      z-index: 1;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 20px;
    }

    header {
      text-align: center;
      padding: 20px 0;
    }

    header h1 {
      font-size: 2.8em;
      margin-bottom: 8px;
      color: var(--text);
      text-shadow: 0 2px 10px rgba(99, 102, 241, 0.3);
    }

    .tagline {
      color: var(--muted);
      font-size: 1.05em;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 20px;
      padding: 32px;
      margin: 20px auto;
      max-width: 900px;
      width: 100%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    #modeScreen {
      text-align: center;
    }

    #modeScreen h2 {
      margin-bottom: 28px;
      font-size: 2em;
      color: var(--text);
    }

    .mode-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin: 28px 0;
    }
    
    .difficulty-select {
      margin-top: 24px;
      padding: 20px;
      background: rgba(99, 102, 241, 0.1);
      border-radius: 12px;
      border: 1px solid var(--line);
    }
    
    .difficulty-select h3 {
      font-size: 1.2em;
      margin-bottom: 16px;
      color: var(--text);
    }
    
    .difficulty-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .difficulty-btn {
      padding: 10px 20px;
      border-radius: 8px;
      border: 2px solid var(--line);
      background: var(--card);
      color: var(--text);
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .difficulty-btn:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    
    .difficulty-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 18px 28px;
      border-radius: 14px;
      font-size: 1.1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-align: left;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);
    }

    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 24px rgba(99, 102, 241, 0.4);
    }

    .btn:active {
      transform: translateY(-1px);
    }

    .btn.mode {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 100px;
      justify-content: center;
    }

    .btn.mode span {
      font-size: 1.3em;
    }

    .btn.mode small {
      opacity: 0.95;
      font-weight: 500;
      font-size: 0.92em;
    }

    .hint {
      margin-top: 20px;
      color: var(--muted);
      font-size: 1em;
      line-height: 1.6;
    }

    #hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 0;
      flex-wrap: wrap;
      gap: 12px;
    }

    .hud-left {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .badge {
      background: var(--card);
      border: 1px solid var(--line);
      color: var(--text);
      border-radius: 10px;
      padding: 10px 18px;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .hud-right {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn.small {
      padding: 10px 18px;
      font-size: 0.95em;
    }

    .btn.ghost {
      background: transparent;
      border: 1px solid var(--line);
      color: var(--muted);
      box-shadow: none;
    }

    .btn.ghost:hover {
      background: var(--line);
      color: var(--text);
    }

    #stage {
      text-align: center;
      margin: 20px auto;
      max-width: 800px;
      width: 100%;
      padding: 0 20px;
    }

    #game {
      width: 100%;
      max-width: 100%;
      height: auto;
      background: var(--hole);
      border-radius: 16px;
      border: 2px solid var(--line);
      cursor: pointer;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: block;
      margin: 0 auto;
    }

    #game:hover {
      border-color: var(--accent);
    }

    #banner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 50;
      box-shadow: 0 24px 48px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      opacity: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #banner.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    #bannerText {
      font-size: 2em;
      font-weight: 700;
      margin-bottom: 24px;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    footer {
      text-align: center;
      padding: 24px;
      color: var(--muted);
      margin-top: auto;
      font-size: 0.95em;
    }

    @media (max-width: 600px) {
      header h1 {
        font-size: 2em;
      }
      
      .card {
        padding: 20px;
      }
      
      #hud {
        flex-direction: column;
        align-items: stretch;
      }
      
      .hud-left, .hud-right {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div id="preloader">
    <div class="spinner"></div>
    <div class="loading-text">Loading Game...</div>
  </div>

  <canvas id="bg"></canvas>

  <main id="app">
    <header>
      <h1>‚ö™ Connect Four üî¥</h1>
      <p class="tagline">Classic strategy game with smooth animations</p>
    </header>

    <section id="modeScreen" class="card">
      <h2>Choose Your Game Mode</h2>
      <div class="mode-grid">
        <button class="btn mode" data-mode="pvp">
          <span>üë• Player vs Player</span>
          <small>Challenge a friend locally</small>
        </button>
        <button class="btn mode" data-mode="ai">
          <span>ü§ñ Player vs AI</span>
          <small>Test your skills against the computer</small>
        </button>
      </div>
      <div class="difficulty-select">
        <h3>AI Difficulty Level</h3>
        <div class="difficulty-buttons">
          <button class="difficulty-btn" data-difficulty="easy">üòä Easy</button>
          <button class="difficulty-btn active" data-difficulty="medium">üòê Medium</button>
          <button class="difficulty-btn" data-difficulty="hard">üòà Hard</button>
        </div>
      </div>
      <p class="hint">üí° Click on any column to drop your disc. Connect four discs in a row (horizontally, vertically, or diagonally) to win!</p>
    </section>

    <section id="hud" class="hidden">
      <div class="hud-left">
        <div class="badge current-player">
          <span id="turnText">Player 1's Turn</span>
        </div>
        <div class="badge">Board: <span id="dimsText">6√ó7</span></div>
      </div>
      <div class="hud-right">
        <button id="restartBtn" class="btn small">üîÑ Restart</button>
        <button id="homeBtn" class="btn small ghost">üè† Home</button>
      </div>
    </section>

    <section id="stage" class="hidden">
      <canvas id="game" width="700" height="600"></canvas>
    </section>

    <div id="banner" class="hidden">
      <div id="bannerText">Player 1 Wins! üéâ</div>
      <button id="bannerRestart" class="btn">Play Again</button>
    </div>

    <footer>
      Built with HTML5 Canvas & Vanilla JavaScript
    </footer>
  </main>

  <script>
    const ROWS = 6;
    const COLS = 7;
    const P1 = 1;
    const P2 = 2;

    let board = [];
    let currentPlayer = P1;
    let winner = null;
    let gameActive = true;
    let currentMode = 'pvp';
    let animating = false;
    let aiDifficulty = 'medium'; // easy, medium, hard

    const preloader = document.getElementById('preloader');
    const modeScreen = document.getElementById('modeScreen');
    const hud = document.getElementById('hud');
    const stage = document.getElementById('stage');
    const gameCanvas = document.getElementById('game');
    const turnTextEl = document.getElementById('turnText');
    const banner = document.getElementById('banner');
    const bannerText = document.getElementById('bannerText');

    function init() {
      setTimeout(() => {
        preloader.style.opacity = '0';
        setTimeout(() => preloader.classList.add('hidden'), 300);
      }, 800);

      setupBackground();
      setupGameCanvas();
      setupEventListeners();
      document.getElementById('dimsText').textContent = `${ROWS}√ó${COLS}`;
    }

    function setupBackground() {
      const canvas = document.getElementById('bg');
      const ctx = canvas.getContext('2d');
      
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        drawBackground();
      }
      
      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#0a0e27');
        gradient.addColorStop(1, '#1a1f3a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      resize();
      window.addEventListener('resize', resize);
    }

    function setupGameCanvas() {
      function resize() {
        const containerWidth = stage.clientWidth;
        const maxWidth = 800;
        const padding = 40;
        const width = Math.min(containerWidth - padding, maxWidth);
        const height = (width * 6) / 7;
        
        gameCanvas.width = width;
        gameCanvas.height = height;
        gameCanvas.style.width = width + 'px';
        gameCanvas.style.height = height + 'px';
        
        if (board.length > 0) drawBoard();
      }
      
      window.addEventListener('resize', resize);
    }

    function createBoard() {
      return Array(ROWS).fill().map(() => Array(COLS).fill(0));
    }

    function drawBoard(highlightCol = -1) {
      const ctx = gameCanvas.getContext('2d');
      const width = gameCanvas.width;
      const height = gameCanvas.height;
      const cellWidth = width / COLS;
      const cellHeight = height / ROWS;
      
      ctx.clearRect(0, 0, width, height);
      
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#2563eb');
      gradient.addColorStop(1, '#1e40af');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      if (highlightCol >= 0 && gameActive && !winner) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(highlightCol * cellWidth, 0, cellWidth, height);
      }
      
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const x = col * cellWidth + cellWidth / 2;
          const y = row * cellHeight + cellHeight / 2;
          const radius = Math.min(cellWidth, cellHeight) * 0.38;
          
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fillStyle = '#0d1225';
          ctx.fill();
          
          const piece = board[row][col];
          if (piece === P1) {
            const grad = ctx.createRadialGradient(x, y, 0, x, y, radius);
            grad.addColorStop(0, '#fca5a5');
            grad.addColorStop(1, '#ef4444');
            ctx.beginPath();
            ctx.arc(x, y, radius - 3, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 2;
            ctx.stroke();
          } else if (piece === P2) {
            const grad = ctx.createRadialGradient(x, y, 0, x, y, radius);
            grad.addColorStop(0, '#fde68a');
            grad.addColorStop(1, '#fbbf24');
            ctx.beginPath();
            ctx.arc(x, y, radius - 3, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }
      }
    }

    async function makeMove(col, isAI = false) {
      if (!gameActive || winner || animating) return false;
      if (!isAI && currentMode === 'ai' && currentPlayer === P2) return false;
      
      for (let row = ROWS - 1; row >= 0; row--) {
        if (board[row][col] === 0) {
          animating = true;
          await animateDrop(row, col, currentPlayer);
          board[row][col] = currentPlayer;
          drawBoard();
          animating = false;
          
          if (checkWin(row, col)) {
            winner = currentPlayer;
            gameActive = false;
            const msg = winner === P1 ? 'üéâ Player 1 Wins!' : 
                       (currentMode === 'ai' ? 'ü§ñ AI Wins!' : 'üéâ Player 2 Wins!');
            showBanner(msg);
            return true;
          }
          
          if (checkDraw()) {
            winner = 0;
            gameActive = false;
            showBanner("ü§ù It's a Draw!");
            return true;
          }
          
          currentPlayer = currentPlayer === P1 ? P2 : P1;
          updateTurnDisplay();
          
          // AI move with slight delay for better UX
          if (currentMode === 'ai' && currentPlayer === P2 && gameActive && !isAI) {
            setTimeout(() => {
              makeAIMove();
            }, 600);
          }
          
          return true;
        }
      }
      return false;
    }

    async function animateDrop(targetRow, col, player) {
      const ctx = gameCanvas.getContext('2d');
      const width = gameCanvas.width;
      const height = gameCanvas.height;
      const cellWidth = width / COLS;
      const cellHeight = height / ROWS;
      const x = col * cellWidth + cellWidth / 2;
      const targetY = targetRow * cellHeight + cellHeight / 2;
      const radius = Math.min(cellWidth, cellHeight) * 0.38;
      
      let y = cellHeight / 2;
      const gravity = 0.8;
      let velocity = 0;
      
      return new Promise(resolve => {
        function animate() {
          velocity += gravity;
          y += velocity;
          
          if (y >= targetY) {
            y = targetY;
            drawBoard();
            resolve();
            return;
          }
          
          drawBoard();
          
          const color = player === P1 ? '#ef4444' : '#fbbf24';
          const grad = ctx.createRadialGradient(x, y, 0, x, y, radius);
          grad.addColorStop(0, player === P1 ? '#fca5a5' : '#fde68a');
          grad.addColorStop(1, color);
          
          ctx.beginPath();
          ctx.arc(x, y, radius - 3, 0, Math.PI * 2);
          ctx.fillStyle = grad;
          ctx.fill();
          ctx.strokeStyle = player === P1 ? '#dc2626' : '#f59e0b';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          requestAnimationFrame(animate);
        }
        animate();
      });
    }

    function makeAIMove() {
      if (!gameActive || winner || animating) return;
      
      const availableColumns = [];
      for (let col = 0; col < COLS; col++) {
        if (board[0][col] === 0) availableColumns.push(col);
      }
      
      if (availableColumns.length === 0) return;
      
      let move = -1;
      
      if (aiDifficulty === 'easy') {
        // Easy: 30% chance to play smart, 70% random
        if (Math.random() < 0.3) {
          move = findWinningMove(P2);
          if (move === -1) move = findWinningMove(P1);
        }
        if (move === -1) {
          move = availableColumns[Math.floor(Math.random() * availableColumns.length)];
        }
      } else if (aiDifficulty === 'medium') {
        // Medium: Win, block, strategic, center preference
        move = findWinningMove(P2);
        if (move === -1) move = findWinningMove(P1);
        if (move === -1) move = findStrategicMove();
        if (move === -1) {
          availableColumns.sort((a, b) => Math.abs(a - 3.5) - Math.abs(b - 3.5));
          move = availableColumns[Math.floor(Math.random() * Math.min(3, availableColumns.length))];
        }
      } else if (aiDifficulty === 'hard') {
        // Hard: Use minimax algorithm with deeper search and advanced evaluation
        move = findBestMoveMinimax(5); // Increased depth from 3 to 5
        if (move === -1) {
          move = findWinningMove(P2);
          if (move === -1) move = findWinningMove(P1);
          if (move === -1) move = findStrategicMove();
        }
      }
      
      if (move === -1) {
        availableColumns.sort((a, b) => Math.abs(a - 3.5) - Math.abs(b - 3.5));
        move = availableColumns[0];
      }
      
      makeMove(move, true);
    }
    
    function findBestMoveMinimax(depth) {
      let bestScore = -Infinity;
      let bestMove = -1;
      
      for (let col = 0; col < COLS; col++) {
        const row = getLowestRow(col);
        if (row === -1) continue;
        
        board[row][col] = P2;
        const score = minimax(depth - 1, -Infinity, Infinity, false);
        board[row][col] = 0;
        
        if (score > bestScore) {
          bestScore = score;
          bestMove = col;
        }
      }
      
      return bestMove;
    }
    
    function minimax(depth, alpha, beta, isMaximizing) {
      // Check terminal states
      const p2Win = checkWinForPlayer(P2);
      const p1Win = checkWinForPlayer(P1);
      
      if (p2Win) return 10000 + depth; // Prefer faster wins
      if (p1Win) return -10000 - depth; // Delay losses
      if (checkDraw()) return 0;
      if (depth === 0) return evaluateBoardState();
      
      if (isMaximizing) {
        let maxScore = -Infinity;
        const moves = getOrderedMoves();
        
        for (const col of moves) {
          const row = getLowestRow(col);
          if (row === -1) continue;
          
          board[row][col] = P2;
          const score = minimax(depth - 1, alpha, beta, false);
          board[row][col] = 0;
          
          maxScore = Math.max(maxScore, score);
          alpha = Math.max(alpha, score);
          if (beta <= alpha) break; // Alpha-beta pruning
        }
        return maxScore;
      } else {
        let minScore = Infinity;
        const moves = getOrderedMoves();
        
        for (const col of moves) {
          const row = getLowestRow(col);
          if (row === -1) continue;
          
          board[row][col] = P1;
          const score = minimax(depth - 1, alpha, beta, true);
          board[row][col] = 0;
          
          minScore = Math.min(minScore, score);
          beta = Math.min(beta, score);
          if (beta <= alpha) break; // Alpha-beta pruning
        }
        return minScore;
      }
    }
    
    function getOrderedMoves() {
      // Order moves from center outward for better pruning
      const moves = [];
      for (let col = 0; col < COLS; col++) {
        moves.push(col);
      }
      moves.sort((a, b) => Math.abs(a - 3) - Math.abs(b - 3));
      return moves;
    }
    
    function evaluateBoardState() {
      let score = 0;
      
      // Center column control is crucial
      const centerCol = 3;
      for (let row = 0; row < ROWS; row++) {
        if (board[row][centerCol] === P2) score += 6;
        else if (board[row][centerCol] === P1) score -= 6;
      }
      
      // Evaluate all positions on the board
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          if (board[row][col] === P2) {
            score += evaluatePosition(row, col, P2) * 2;
            score += evaluateThreats(row, col, P2);
          } else if (board[row][col] === P1) {
            score -= evaluatePosition(row, col, P1) * 2;
            score -= evaluateThreats(row, col, P1);
          }
        }
      }
      
      // Check for potential traps and double threats
      score += evaluateDoubleThreats(P2) * 100;
      score -= evaluateDoubleThreats(P1) * 100;
      
      return score;
    }
    
    function evaluateThreats(row, col, player) {
      let threatScore = 0;
      const directions = [
        [0, 1],   // horizontal
        [1, 0],   // vertical
        [1, 1],   // diagonal \
        [1, -1]   // diagonal /
      ];
      
      for (const [dr, dc] of directions) {
        let count = 0;
        let spaces = 0;
        let blocked = 0;
        
        // Check in both directions
        for (let i = -3; i <= 3; i++) {
          if (i === 0) continue;
          const r = row + dr * i;
          const c = col + dc * i;
          if (r < 0 || r >= ROWS || c < 0 || c >= COLS) continue;
          
          if (board[r][c] === player) count++;
          else if (board[r][c] === 0) spaces++;
          else blocked++;
        }
        
        // Three in a row with open space = big threat
        if (count >= 2 && spaces > 0 && blocked === 0) {
          threatScore += 30;
        }
      }
      
      return threatScore;
    }
    
    function evaluateDoubleThreats(player) {
      let threats = 0;
      
      // Count how many ways this player can win in the next move
      for (let col = 0; col < COLS; col++) {
        const row = getLowestRow(col);
        if (row === -1) continue;
        
        board[row][col] = player;
        if (checkWinForPlayer(player)) {
          threats++;
        }
        board[row][col] = 0;
      }
      
      // Having 2+ winning threats means opponent can't block both
      return threats >= 2 ? threats : 0;
    }
    
    function getLowestRow(col) {
      for (let row = ROWS - 1; row >= 0; row--) {
        if (board[row][col] === 0) return row;
      }
      return -1;
    }
    
    function checkWinForPlayer(player) {
      // Check all possible win conditions for a specific player
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          if (board[row][col] !== player) continue;
          
          // Horizontal
          if (col <= COLS - 4) {
            if (board[row][col + 1] === player &&
                board[row][col + 2] === player &&
                board[row][col + 3] === player) return true;
          }
          
          // Vertical
          if (row <= ROWS - 4) {
            if (board[row + 1][col] === player &&
                board[row + 2][col] === player &&
                board[row + 3][col] === player) return true;
          }
          
          // Diagonal \
          if (row <= ROWS - 4 && col <= COLS - 4) {
            if (board[row + 1][col + 1] === player &&
                board[row + 2][col + 2] === player &&
                board[row + 3][col + 3] === player) return true;
          }
          
          // Diagonal /
          if (row >= 3 && col <= COLS - 4) {
            if (board[row - 1][col + 1] === player &&
                board[row - 2][col + 2] === player &&
                board[row - 3][col + 3] === player) return true;
          }
        }
      }
      return false;
    }
    
    function findStrategicMove() {
      const availableColumns = [];
      for (let col = 0; col < COLS; col++) {
        if (board[0][col] === 0) availableColumns.push(col);
      }
      
      // Look for moves that create multiple threats
      let bestMove = -1;
      let bestScore = -1;
      
      for (const col of availableColumns) {
        for (let row = ROWS - 1; row >= 0; row--) {
          if (board[row][col] === 0) {
            board[row][col] = P2;
            const score = evaluatePosition(row, col, P2);
            board[row][col] = 0;
            
            if (score > bestScore) {
              bestScore = score;
              bestMove = col;
            }
            break;
          }
        }
      }
      
      return bestScore > 0 ? bestMove : -1;
    }
    
    function evaluatePosition(row, col, player) {
      let score = 0;
      
      // Check all directions for potential connections
      const directions = [
        [0, 1],   // horizontal
        [1, 0],   // vertical
        [1, 1],   // diagonal \
        [1, -1]   // diagonal /
      ];
      
      for (const [dr, dc] of directions) {
        let count = 1;
        let openEnds = 0;
        
        // Check positive direction
        for (let i = 1; i < 4; i++) {
          const r = row + dr * i;
          const c = col + dc * i;
          if (r < 0 || r >= ROWS || c < 0 || c >= COLS) break;
          if (board[r][c] === player) count++;
          else if (board[r][c] === 0) {
            openEnds++;
            break;
          } else break;
        }
        
        // Check negative direction
        for (let i = 1; i < 4; i++) {
          const r = row - dr * i;
          const c = col - dc * i;
          if (r < 0 || r >= ROWS || c < 0 || c >= COLS) break;
          if (board[r][c] === player) count++;
          else if (board[r][c] === 0) {
            openEnds++;
            break;
          } else break;
        }
        
        // Score based on connected pieces and open ends
        if (count >= 3 && openEnds > 0) score += 50;
        else if (count === 2 && openEnds === 2) score += 10;
        else if (count === 2 && openEnds === 1) score += 5;
      }
      
      // Bonus for center column
      if (col === 3) score += 3;
      else if (col === 2 || col === 4) score += 2;
      
      return score;
    }

    function findWinningMove(player) {
      for (let col = 0; col < COLS; col++) {
        for (let row = ROWS - 1; row >= 0; row--) {
          if (board[row][col] === 0) {
            board[row][col] = player;
            const wins = checkWin(row, col);
            board[row][col] = 0;
            if (wins) return col;
            break;
          }
        }
      }
      return -1;
    }

    function checkWin(row, col) {
      const player = board[row][col];
      
      for (let c = 0; c <= COLS - 4; c++) {
        if (board[row][c] === player &&
            board[row][c + 1] === player &&
            board[row][c + 2] === player &&
            board[row][c + 3] === player) return true;
      }
      
      for (let r = 0; r <= ROWS - 4; r++) {
        if (board[r][col] === player &&
            board[r + 1][col] === player &&
            board[r + 2][col] === player &&
            board[r + 3][col] === player) return true;
      }
      
      for (let r = 0; r <= ROWS - 4; r++) {
        for (let c = 0; c <= COLS - 4; c++) {
          if (board[r][c] === player &&
              board[r + 1][c + 1] === player &&
              board[r + 2][c + 2] === player &&
              board[r + 3][c + 3] === player) return true;
        }
      }
      
      for (let r = 3; r < ROWS; r++) {
        for (let c = 0; c <= COLS - 4; c++) {
          if (board[r][c] === player &&
              board[r - 1][c + 1] === player &&
              board[r - 2][c + 2] === player &&
              board[r - 3][c + 3] === player) return true;
        }
      }
      
      return false;
    }

    function checkDraw() {
      return board[0].every(cell => cell !== 0);
    }

    function startGame(mode) {
      currentMode = mode;
      board = createBoard();
      currentPlayer = P1;
      winner = null;
      gameActive = true;
      animating = false;
      
      modeScreen.classList.add('hidden');
      hud.classList.remove('hidden');
      stage.classList.remove('hidden');
      
      updateTurnDisplay();
      
      const containerWidth = stage.clientWidth;
      const maxWidth = 800;
      const padding = 40;
      const width = Math.min(containerWidth - padding, maxWidth);
      const height = (width * 6) / 7;
      
      gameCanvas.width = width;
      gameCanvas.height = height;
      gameCanvas.style.width = width + 'px';
      gameCanvas.style.height = height + 'px';
      
      drawBoard();
    }

    function resetGame() {
      board = createBoard();
      currentPlayer = P1;
      winner = null;
      gameActive = true;
      animating = false;
      hideBanner();
      updateTurnDisplay();
      drawBoard();
    }

    function goHome() {
      modeScreen.classList.remove('hidden');
      hud.classList.add('hidden');
      stage.classList.add('hidden');
      hideBanner();
      gameActive = false;
    }

    function updateTurnDisplay() {
      const playerText = currentPlayer === P1 ? 
        "üî¥ Player 1's Turn" : 
        (currentMode === 'ai' ? "ü§ñ AI's Turn" : "üü° Player 2's Turn");
      turnTextEl.textContent = playerText;
    }

    function showBanner(message) {
      bannerText.textContent = message;
      banner.classList.remove('hidden');
      setTimeout(() => banner.classList.add('show'), 10);
    }

    function hideBanner() {
      banner.classList.remove('show');
      setTimeout(() => banner.classList.add('hidden'), 300);
    }

    function setupEventListeners() {
      document.querySelectorAll('.btn.mode').forEach(btn => {
        btn.addEventListener('click', (e) => {
          startGame(e.currentTarget.dataset.mode);
        });
      });
      
      // Difficulty selection
      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
          e.currentTarget.classList.add('active');
          aiDifficulty = e.currentTarget.dataset.difficulty;
        });
      });
      
      document.getElementById('restartBtn').addEventListener('click', resetGame);
      document.getElementById('homeBtn').addEventListener('click', goHome);
      document.getElementById('bannerRestart').addEventListener('click', resetGame);
      
      gameCanvas.addEventListener('mousemove', (e) => {
        if (!gameActive || winner || animating) return;
        if (currentMode === 'ai' && currentPlayer === P2) return;
        
        const rect = gameCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const col = Math.floor((x / rect.width) * COLS);
        
        if (col >= 0 && col < COLS) {
          drawBoard(col);
        }
      });
      
      gameCanvas.addEventListener('mouseleave', () => {
        drawBoard();
      });
      
      gameCanvas.addEventListener('click', (e) => {
        if (!gameActive || winner || animating) return;
        if (currentMode === 'ai' && currentPlayer === P2) return;
        
        const rect = gameCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const col = Math.floor((x / rect.width) * COLS);
        
        if (col >= 0 && col < COLS) {
          makeMove(col);
        }
      });
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
